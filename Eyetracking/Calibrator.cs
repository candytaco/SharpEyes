using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using Num = NumSharp.np;

// Note: try not to use NumSharp data structures in these classes
// Because they're interally contained

namespace Eyetracking
{
	/// <summary>
	/// Performs the actual math for mapping between eyetracking video space to stimulus frames space
	/// </summary>
	class Calibrator
	{
		/// <summary>
		/// Description of the calibration sequence
		/// </summary>
		private CalibrationParameters calibrationParameters;
		
		/// <summary>
		/// Averaged positions of the pupil at the calibration points
		/// in order that they are presented in.
		/// </summary>
		private List<Point> calibrationPositions = null;

		private RBF2D xInterpolator = null, yInterpolator = null;

		public Calibrator(CalibrationParameters parameters)
		{
			calibrationParameters = parameters;
		}

		public Calibrator(CalibrationParameters parameters, List<Point> positions)
		{
			calibrationParameters = parameters;
			calibrationPositions = positions;
		}

		public void Calibrate()
		{
			Calibrate(this.calibrationPositions);
		}

		public void Calibrate(List<Point> positions)
		{
			calibrationPositions = positions;
			double[] pupilX = new double[positions.Count];
			double[] pupilY = new double[positions.Count];
			double[] screenX = new double[positions.Count];
			double[] screenY = new double[positions.Count];

			for (int i = 0; i < positions.Count; i++)
			{
				pupilX[i] = positions[i].X;
				pupilY[i] = positions[i].Y;
				// remember this indexing exists because the order in which the points are presented is
				// not the same as they are generated by the loop
				screenX[i] = calibrationParameters.calibrationPoints[calibrationParameters.calibrationSequence[i]].X;
				screenY[i] = calibrationParameters.calibrationPoints[calibrationParameters.calibrationSequence[i]].Y;
			}

			//
			xInterpolator = RBF2D.LeaveOneOutSelect(pupilX, pupilY, screenX, calibrationParameters.baseRadiusRange, calibrationParameters.numBaseRadii,
													calibrationParameters.numLayersRange, calibrationParameters.regularizerRange, calibrationParameters.numRegularizers,
													calibrationParameters.logSpaceRegularizers);
			yInterpolator = RBF2D.LeaveOneOutSelect(pupilX, pupilY, screenY, calibrationParameters.baseRadiusRange, calibrationParameters.numBaseRadii,
													calibrationParameters.numLayersRange, calibrationParameters.regularizerRange, calibrationParameters.numRegularizers,
													calibrationParameters.logSpaceRegularizers);
		}
		
	}


	/// <summary>
	/// Encapsulated two RBF2D objects to map between two 2D coordinate systems.
	/// Exists because we need to optimize RMS errors in 2D
	/// </summary>
	class RBF2DTo2D
	{
		RBF2D xInterpolator = null, yInterpolator = null;

		/// <summary>
		/// Performs leave-one-out selection of best hyperparameter values for the RBF
		/// </summary>
		/// <param name="x">data X</param>
		/// <param name="y">data Y</param>
		/// <param name="value">data values at (X, Y)</param>
		/// <param name="baseRadiusRange">range of values for the base radius, must > 0</param>
		/// <param name="numBaseRadii">number of values for the base radius</param>
		/// <param name="numLayersRange">number of layers, must be > 0</param>
		/// <param name="regularizerRange">range of regularizers to use, must be >= 0</param>
		/// <param name="numRegularizers">number of regularizers</param>
		/// <param name="logSpaceRegularizers">log space instead of linearly space regularizers?</param>
		/// <returns>RBF fit on all of the data using the parameter that generated the lowest sum of squares loss</returns>
		public static RBF2DTo2D LeaveOneOutSelect(double[] x, double[] y, double[] value, Tuple<double, double> baseRadiusRange, int numBaseRadii,
												  Tuple<int, int> numLayersRange, Tuple<double, double> regularizerRange, int numRegularizers, bool logSpaceRegularizers)
		{
			RBF2DTo2D best = null;

			return best;
		}

		public double CrossValidate()
		{
			double bestError = double.PositiveInfinity;


			return bestError;
		}
	}


	/// <summary>
	/// Object-oriented wrapper to alglib's hierarchical RBF functions.
	/// Specifically maps a 2D values to a scalar
	/// </summary>
	class RBF2D
	{
		/// <summary>
		/// Performs leave-one-out selection of best hyperparameter values for the RBF
		/// </summary>
		/// <param name="x">data X</param>
		/// <param name="y">data Y</param>
		/// <param name="value">data values at (X, Y)</param>
		/// <param name="baseRadiusRange">range of values for the base radius, must > 0</param>
		/// <param name="numBaseRadii">number of values for the base radius</param>
		/// <param name="numLayersRange">number of layers, must be > 0</param>
		/// <param name="regularizerRange">range of regularizers to use, must be >= 0</param>
		/// <param name="numRegularizers">number of regularizers</param>
		/// <param name="logSpaceRegularizers">log space instead of linearly space regularizers?</param>
		/// <returns>RBF fit on all of the data using the parameter that generated the lowest sum of squares loss</returns>
		public static RBF2D LeaveOneOutSelect(double[] x, double[] y, double[] value, Tuple<double, double> baseRadiusRange, int numBaseRadii, 
											  Tuple<int, int> numLayersRange, Tuple<double, double> regularizerRange, int numRegularizers, bool logSpaceRegularizers)
		{
			RBF2D best = null;
			double bestError = Double.PositiveInfinity;
			List<double> regularizers = new List<double>
			{
				regularizerRange.Item1
			};
			double start = regularizerRange.Item1;
			double end = regularizerRange.Item2;
			if (logSpaceRegularizers)
			{
				start = start == 0 ? -6 : Math.Log(start);
				end = Math.Log(end);
			}
			foreach (double regularizer in Num.linspace(start, end, regularizerRange.Item1 == 0 ? numRegularizers - 1 : numRegularizers))
			{
				regularizers.Add(logSpaceRegularizers ? Math.Pow(10, regularizer) : regularizer);
			}

			foreach (double baseRadius in Num.linspace(baseRadiusRange.Item1, baseRadiusRange.Item2, numBaseRadii))
				for (int numLayers = numLayersRange.Item1; numLayers < numLayersRange.Item2 + 1; numLayers++)
					foreach (double regularizer in regularizers)
					{
						RBF2D RBF = new RBF2D(x, y, value);
						RBF.baseRadius = baseRadius;
						RBF.numLayers = numLayers;
						RBF.regularizer = regularizer;
						double error = RBF.CrossValidate();
						if (error < bestError)
						{
							best = RBF;
							bestError = error;
						}
					}
			return best;
		}

		private alglib.rbfmodel RBFModel;
		private alglib.rbfreport RBFReport;

		private double[] dataX;
		private double[] dataY;
		private double[] dataValue;

		public Nullable<double> baseRadius = null;
		public int numLayers = 5;
		public double regularizer = 0;

		public double RMSError { get; private set; } = 10000;

		public RBF2D()
		{
			alglib.rbfcreate(2, 1, out RBFModel);
		}

		public RBF2D(double[] x, double[] y, double[] value)
		{
			alglib.rbfcreate(2, 1, out RBFModel);
			dataX = x;
			dataY = y;
			dataValue = value;
		}

		public void Fit()
		{
			Fit(dataX, dataY, dataValue);
		}

		public void Fit(double[] x, double[] y, double[] value)
		{
			dataX = x;
			dataY = y;
			dataValue = value;

			// alglib expects a 2D array in [sample, x-y-value]
			double[,] formattedData = new double[dataX.Length, 3];
			for (int i = 0; i < dataX.Length; i++)
			{
				formattedData[i, 0] = dataX[i];
				formattedData[i, 1] = dataY[i];
				formattedData[i, 2] = dataValue[i];
			}
			alglib.rbfsetpoints(RBFModel, formattedData);

			// this call sets the algorithms and have hyperparameters that need tuning
			alglib.rbfsetalgohierarchical(RBFModel, baseRadius ?? 1.0, numLayers, regularizer);

			alglib.rbfbuildmodel(RBFModel, out RBFReport);
		}

		/// <summary>
		/// Does leave-one-out cross validation and stores the mean error
		/// </summary>
		public double CrossValidate()
		{
			double sumErrorSquared = 0;
			object parallelLock = new object();
			Parallel.For(0, dataX.Length, i => 
			{
				alglib.rbfmodel thisModel;
				alglib.rbfreport thisReport;
				alglib.rbfcreate(2, 1, out thisModel);

				double[,] formattedData = new double[dataX.Length - 1, 3];
				int index = 0;
				for (int j = 0; j < dataX.Length; j++)
				{
					if (j == i) continue;
					formattedData[index, 0] = dataX[j];
					formattedData[index, 1] = dataY[j];
					formattedData[index++, 2] = dataValue[j];
				}
				alglib.rbfsetpoints(thisModel, formattedData);
				alglib.rbfsetalgohierarchical(thisModel, baseRadius ?? 1.0, numLayers, regularizer);
				alglib.rbfbuildmodel(thisModel, out thisReport);

				double error = alglib.rbfcalc2(thisModel, dataX[i], dataY[i]) - dataValue[i];
				lock (parallelLock)
				{
					sumErrorSquared += error * error;
				}
			});
			RMSError = Math.Sqrt(sumErrorSquared / dataX.Length);
			return RMSError;
		}

		public double Evaluate(double x, double y)
		{
			return alglib.rbfcalc2(RBFModel, x, y);
		}
	}
}
